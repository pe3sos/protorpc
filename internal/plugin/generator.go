package plugin

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"strconv"
	"unicode"
	"unicode/utf8"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	fmtPackage      = protogen.GoImportPath("fmt")
	contextPackage  = protogen.GoImportPath("context")
	protoRpcPackage = protogen.GoImportPath("github.com/zippunov/protorpc")
	protoPackage    = protogen.GoImportPath("google.golang.org/protobuf/proto")
)

type fileInfo struct {
	*protogen.File

	allServices []*serviceInfo

	allServicesByPtr map[*serviceInfo]int // value is index into allServices
}

func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + ".pbrpc.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	f := newFileInfo(file)

	genGeneratedHeader(gen, g, f)
	g.P("package ", f.GoPackageName)
	g.P()

	for i, imps := 0, f.Desc.Imports(); i < imps.Len(); i++ {
		genImport(gen, g, f, imps.Get(i))
	}

	g.P()

	for _, service := range f.allServices {
		genService(g, f, service)
	}
	return g
}

func newFileInfo(file *protogen.File) *fileInfo {
	f := &fileInfo{File: file}

	initServiceInfos := func(services []*protogen.Service) {
		for _, service := range services {
			f.allServices = append(f.allServices, newServiceInfo(f, service))
		}
	}
	initServiceInfos(f.Services)

	if len(f.allServices) > 0 {
		f.allServicesByPtr = make(map[*serviceInfo]int)
		for i, s := range f.allServices {
			f.allServicesByPtr[s] = i
		}
	}
	return f
}

type serviceInfo struct {
	*protogen.Service
}

func newServiceInfo(f *fileInfo, service *protogen.Service) *serviceInfo {
	e := &serviceInfo{Service: service}
	return e
}

func genGeneratedHeader(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo) {
	g.P("// Code generated by protoc-gen-go-protorpc. DO NOT EDIT.")
	g.P("// versions:")
	protocGenGoProtorpcVersion := "(unknown)"
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
	}
	g.P("// \tprotoc-gen-go-protorpc ", protocGenGoProtorpcVersion)
	g.P("// \tprotoc        ", protocVersion)

	if f.Proto.GetOptions().GetDeprecated() {
		g.P("// ", f.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", f.Desc.Path())
	}
	g.P()
}

func genImport(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, imp protoreflect.FileImport) {
	impFile, ok := gen.FilesByPath[imp.Path()]
	if !ok {
		return
	}
	if impFile.GoImportPath == f.GoImportPath {
		// Don't generate imports or aliases for types in the same Go package.
		return
	}
	// Generate imports for all non-weak dependencies, even if they are not
	// referenced, because other code and tools depend on having the
	// full transitive closure of protocol buffer types in the binary.
	if !imp.IsWeak {
		g.Import(impFile.GoImportPath)
	}
	if !imp.IsPublic {
		return
	}

	// Generate public imports by generating the imported file, parsing it,
	// and extracting every symbol that should receive a forwarding declaration.
	impGen := GenerateFile(gen, impFile)
	impGen.Skip()
	b, err := impGen.Content()
	if err != nil {
		gen.Error(err)
		return
	}
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", b, parser.ParseComments)
	if err != nil {
		gen.Error(err)
		return
	}
	genForward := func(tok token.Token, name string, expr ast.Expr) {
		// Don't import unexported symbols.
		r, _ := utf8.DecodeRuneInString(name)
		if !unicode.IsUpper(r) {
			return
		}
		// Don't import the FileDescriptor.
		if name == impFile.GoDescriptorIdent.GoName {
			return
		}
		// Don't import decls referencing a symbol defined in another package.
		// i.e., don't import decls which are themselves public imports:
		//
		//	type T = somepackage.T
		if _, ok := expr.(*ast.SelectorExpr); ok {
			return
		}
		g.P(tok, " ", name, " = ", impFile.GoImportPath.Ident(name))
	}
	g.P("// Symbols defined in public import of ", imp.Path(), ".")
	g.P()
	for _, decl := range astFile.Decls {
		switch decl := decl.(type) {
		case *ast.GenDecl:
			for _, spec := range decl.Specs {
				switch spec := spec.(type) {
				case *ast.TypeSpec:
					genForward(decl.Tok, spec.Name.Name, spec.Type)
				case *ast.ValueSpec:
					for i, name := range spec.Names {
						var expr ast.Expr
						if i < len(spec.Values) {
							expr = spec.Values[i]
						}
						genForward(decl.Tok, name.Name, expr)
					}
				case *ast.ImportSpec:
				default:
					panic(fmt.Sprintf("can't generate forward for spec type %T", spec))
				}
			}
		}
	}
	g.P()
}

func genService(g *protogen.GeneratedFile, f *fileInfo, service *serviceInfo) {
	// Service interface
	g.P("// WebSocket Server API for ", service.GoName, " service")
	g.P()
	serviceType := service.GoName + "Service"

	g.P("type ", serviceType, " interface {")
	for _, method := range service.Methods {
		g.P()
		g.P(generateMethodSignature(g, method))
	}
	g.P("}")
	g.P()

	// Service endpoints.
	var handlerNames []string
	for _, method := range service.Methods {
		hname := generateServiceMethod(g, service.GoName, method)
		handlerNames = append(handlerNames, hname)
	}

	// Service descriptor.
	descriptor := service.GoName + "ServiceDescriptor"
	g.P("var ", descriptor, " = ", g.QualifiedGoIdent(protoRpcPackage.Ident("ServiceDescriptor")), " {")
	g.P("Name: ", strconv.Quote(string(service.Desc.FullName())), ",")
	g.P("HandlerType: (*", serviceType, ")(nil),")
	g.P("Methods: []", g.QualifiedGoIdent(protoRpcPackage.Ident("MethodMap")), "{")
	for i, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}
		g.P("{")
		g.P("Name: ", strconv.Quote(string(method.Desc.Name())), ",")
		g.P("Handler: ", handlerNames[i], ",")
		g.P("},")
	}
	g.P("},")
	g.P("About: \"\",")
	g.P("}")
	g.P()
}

func generateMethodSignature(g *protogen.GeneratedFile, m *protogen.Method) string {
	ctxIdent := g.QualifiedGoIdent(contextPackage.Ident("Context"))
	inIdent := g.QualifiedGoIdent(m.Input.GoIdent)
	outIdent := g.QualifiedGoIdent(m.Output.GoIdent)
	return m.GoName + "( ctx " + ctxIdent + ", in *" + inIdent + ") " + "(*" + outIdent + ", error)"
}

func generateServiceMethod(g *protogen.GeneratedFile, serviceName string, method *protogen.Method) string {
	ctxIdent := g.QualifiedGoIdent(contextPackage.Ident("Context"))
	errorfIdent := g.QualifiedGoIdent(fmtPackage.Ident("Errorf"))
	messageIdent := g.QualifiedGoIdent(protoPackage.Ident("Message"))
	methodName := method.GoName
	fullName := fmt.Sprintf("%s%sHandler", serviceName, methodName)
	inType := g.QualifiedGoIdent(method.Input.GoIdent)

	g.P("func ", fullName, "(implementation interface{}, ctx ", ctxIdent, ", payload ", messageIdent, ") (", messageIdent, ", error) {")
	g.P("in, ok := payload.(*", inType, ")")
	g.P("if !ok {")
	g.P(`return nil, `, errorfIdent, `("input is not of type *`+inType+`")`)
	g.P("}")

	g.P("out, error := implementation.(", serviceName, "Service).", methodName, "(ctx, in);")
	g.P("if error != nil {")
	g.P("return nil, error")
	g.P("}")
	g.P("return out, nil")
	g.P("}")
	g.P()

	return fullName
}
